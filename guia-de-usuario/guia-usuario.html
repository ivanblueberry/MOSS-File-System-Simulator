<html>
<head>
<title>Moss | Simulador de Sistema de Archivos | Guía del Usuario</title>
</head>

<link rel="stylesheet" href="styles.css">


<body bgcolor="#ffffff">
<h1>
Simulador de Sistema de Archivos MOSS
<br>Guía del Usuario</h1>

<h2>Contenido</h2>
<ul>
<li><a href="#purpose">Propósito</a>
<li><a href="#introduction">Introducción</a>
<li><a href="#overview">Resumen</a>
<li><a href="#prog">Uso de los Programas del Simulador de Sistema de Archivos</a>
<ul>
<li><a href="#prog.mkfs">Uso de mkfs</a>
<li><a href="#prog.mkdir">Uso de mkdir</a>
<li><a href="#prog.ls">Uso de ls</a>
<li><a href="#prog.tee">Uso de tee</a>
<li><a href="#prog.cp">Uso de cp</a>
<li><a href="#prog.cat">Uso de cat</a>
</ul>
<li><a href="#dump">Volcado del Sistema de Archivos</a>
<li><a href="#conf">Archivo de Configuración del Simulador</a>
<ul>
<li><a href="#conf.options">Opciones del Archivo de Configuración</a>
<li><a href="#conf.sample">Un Archivo de Configuración de Ejemplo</a>
<li><a href="#conf.alt">Especificación de un Archivo de Configuración Alternativo</a>
</ul>
<li><a href="#writing">Escritura de Programas para el Simulador de Sistema de Archivos</a>
<li><a href="#enhancing">Mejoras al Simulador de Sistema de Archivos</a>
<li><a href="#exercises">Ejercicios Sugeridos</a>
<li><a href="#todo">Por Hacer</a>
<li><a href="#copyright">Derechos de Autor</a>
</ul>

<h2><a name="purpose">Propósito</a></h2>

<p>
Este documento es una guía del usuario para el Simulador de Sistema de Archivos MOSS.  
Explica cómo usar el simulador y describe los programas y los diversos archivos de entrada utilizados y los archivos de salida producidos por el simulador.
El software MOSS está diseñado para ser utilizado con 
<a href="http://www.cs.vu.nl/~ast/">Andrew S. Tanenbaum</a>, 
<a href="http://vig.prenhall.com/catalog/academic/product/1,4096,0130313580,00.html">Sistemas Operativos Modernos, 2ª Edición</a> 
(<a href="http://www.prenhall.com/">Prentice Hall</a>, 2001).  
El Simulador de Sistema de Archivos y la documentación fueron escritos por 
<a href="http://www.ontko.com/~rayo/">Ray Ontko</a>
(<a href="mailto:rayo@ontko.com"><i>rayo@ontko.com</i></a>).

<p>
Esta Guía del Usuario asume que ya ha instalado y probado el simulador.
Si está buscando información sobre la instalación, por favor lea la 
<a href="install_unix.html">Guía de Instalación para Sistemas Unix/Linux/Solaris/HP-UX</a> o la 
<a href="install_windows.html">Guía de Instalación para Sistemas Win95/98/Me/NT/2000</a>.

<h2><a name="introduction">Introducción</a></h2>
<p>
El simulador de sistema de archivos muestra el funcionamiento interno de un sistema de archivos UNIX V7. 
El simulador lee o crea un archivo que representa la imagen del disco y realiza un seguimiento de los bloques asignados y libres utilizando un mapa de bits. Un ejercicio típico podría ser que los estudiantes escriban un programa (en Java) que invoque varias llamadas simuladas al sistema operativo contra una imagen de disco conocida proporcionada por el instructor. Los estudiantes también pueden ser solicitados a implementar bloques indirectos, gestión de bloques libres basada en listas, o escribir una utilidad (como fsck) para verificar y reparar el sistema de archivos.

<h2><a name="overview">Resumen</a></h2>

<p>
El Simulador de Sistema de Archivos MOSS es una colección de clases Java que simulan las llamadas al sistema de archivos disponibles en un sistema operativo típico tipo Unix. La clase "Kernel" contiene métodos (funciones) como "creat()", "open()", "read()", "write()", "close()", etc., que leen y escriben bloques en un archivo subyacente de manera similar a como un sistema de archivos real leería y escribiría bloques en un dispositivo de disco subyacente.

<p>
Además de la clase "Kernel", hay varias clases subyacentes que soportan la implementación del kernel. Las clases FileSystem, IndexNode, DirectoryEntry, SuperBlock, Block, BitBlock, FileDescriptor y Stat contienen todas las estructuras de datos y algoritmos que implementan el sistema de archivos simulado.

<p>
También se incluyen varios programas de ejemplo que pueden usarse para operar en un sistema de archivos simulado. Los programas Java "ls", "cat", "mkdir", "mkfs", etc., realizan operaciones de sistema de archivos para listar directorios, mostrar archivos, crear directorios y crear (inicializar) sistemas de archivos. Estos programas ilustran las diversas llamadas al sistema de archivos y permiten al usuario realizar varias operaciones de lectura y escritura en el sistema de archivos simulado.

<p>
Como se mencionó anteriormente, hay un archivo de respaldo para nuestro sistema de archivos simulado. Se incluye un programa "dump" en la distribución para que pueda examinar este archivo, byte por byte. Cualquier programa de volcado puede ser utilizado (por ejemplo, el programa "od" en Unix); incluimos este que es simple de usar y entender, y puede ser utilizado con cualquier sistema operativo.

<p>
Hay varias formas en que puede usar el simulador para obtener una mejor comprensión de los sistemas de archivos. Puede:
<ul>
<li>usar los programas de utilidad proporcionados (<tt>mkfs</tt>, <tt>mkdir</tt>, <tt>ls</tt>, <tt>cat</tt>, etc.) para realizar operaciones en el sistema de archivos simulado y usar el programa <tt>dump</tt> para examinar el archivo subyacente y observar cualquier cambio,
<li>examinar los programas de utilidad de ejemplo para ver cómo usan la interfaz de llamadas al sistema para realizar operaciones de archivos,
<li>mejorar los programas de utilidad de ejemplo para proporcionar funcionalidad adicional,
<li>escribir sus propios programas de utilidad para extender la funcionalidad del sistema de archivos simulado, y
<li>modificar las clases subyacentes de Kernel y otras clases de implementación para extender la funcionalidad del sistema de archivos.
</ul>
En las secciones siguientes, aprenderá lo que necesita saber para realizar cada una de estas actividades.

<h2><a name="prog">Uso de los Programas del Simulador de Sistema de Archivos</a></h2>

<h3><a name="prog.mkfs">Uso de <tt>mkfs</tt></a></h3>

<p>
El programa <tt>mkfs</tt> crea un archivo de respaldo para el sistema de archivos. Esto lo hace creando un archivo cuyo tamaño es especificado por el tamaño de bloque y el número de bloques dados. Escribe el superbloque, los bloques de la lista libre, los bloques de inodos y los bloques de datos para un nuevo sistema de archivos. Tenga en cuenta que sobrescribirá cualquier archivo existente con el nombre especificado, así que tenga cuidado al usar este programa.

<p>
Este programa es similar al programa "mkfs" que se encuentra en sistemas operativos tipo Unix.
<p>
El formato general para el comando <tt>mkfs</tt> es:
<blockquote><pre>
java mkfs <i>nombre-del-archivo</i> <i>tamaño-del-bloque</i> <i>bloques</i>
</pre></blockquote>
donde:
<dl>
<dt><i>nombre-del-archivo</i>
<dd>es el nombre del archivo de respaldo a crear (por ejemplo, <tt>filesys.dat</tt>). 
Note que este es el nombre de un archivo real, no un archivo en el simulador. Este es el archivo que el simulador usa para simular el dispositivo de disco para el sistema de archivos simulado. Este puede ser cualquier nombre de archivo válido en su entorno de sistema operativo.
<dt><i>tamaño-del-bloque</i>
<dd>es el tamaño de bloque que se usará para el sistema de archivos (por ejemplo, <tt>256</tt>). 
Este debe ser un múltiplo del tamaño del nodo índice (inodo, generalmente 64) y del tamaño de la entrada de directorio (generalmente 16). Los sistemas operativos modernos suelen usar un tamaño de 1024 o 512 bytes. Usamos tamaños de bloque de 128 o 256 bytes en muchos de nuestros ejemplos para que pueda ver rápidamente lo que sucede cuando los directorios crecen más allá de un bloque. Este debe ser un número decimal no menor a 64, pero menor a 32768.
<dt><i>bloques</i>
<dd>es el número de bloques a crear en el sistema de archivos (por ejemplo, <tt>40</tt>). 
Este número incluye cualquier bloque que pueda ser usado para el superbloque, la gestión de la lista libre, los inodos y los bloques de datos. Usamos un número relativamente pequeño aquí para que pueda ver rápidamente lo que sucede si se queda sin espacio en el disco. Este puede ser cualquier número decimal mayor a 3, pero no mayor a 2<sup>24</sup> - 1 (el número máximo de bloques), aunque es posible que no tenga suficiente espacio para crear un archivo muy grande.
</dl>

Por ejemplo, el comando:
<blockquote><pre>
java mkfs filesys.dat 256 40
</pre></blockquote>
creará (o sobrescribirá) un archivo "filesys.dat" que contendrá 40 bloques de 256 bytes para un total de 10240 bytes.

<p>
La salida del comando debería verse algo así:
<blockquote><pre>
tamaño_del_bloque: 256
bloques: 40
super_bloques: 1
bloques_de_lista_libre: 1
bloques_de_inodos: 8
bloques_de_datos: 30
total_de_bloques: 40

</pre></blockquote>
De la salida puede ver que se necesita un bloque para el superbloque, uno para la gestión de la lista libre, ocho para los nodos índice y los 30 restantes están disponibles para bloques de datos.

<p>
¿Por qué hay 1 bloque para la gestión de la lista libre? Tenga en cuenta que 30 bloques requieren 30 bits en el mapa de bits de la lista libre. Dado que 256 bytes/bloque * 8 bits/byte = 2048 bits/bloque, claramente un bloque de mapa de bits es suficiente para rastrear la asignación de bloques para este sistema de archivos.

<p>
¿Por qué hay 8 bloques para los nodos índice? Tenga en cuenta que 30 bloques podrían resultar en 30 inodos si se crean muchos archivos o directorios de un bloque. Dado que cada inodo requiere 64 bytes, solo 4 caben en un bloque. Por lo tanto, se reservan 8 bloques para hasta 32 inodos.

<h3><a name="prog.mkdir">Uso de <tt>mkdir</tt></a></h3>

<p>
El programa <tt>mkdir</tt> se puede usar para crear nuevos directorios en nuestro sistema de archivos simulado. Esto lo hace creando el archivo especificado como un archivo de directorio y luego escribiendo las entradas de directorio para "." y ".." en el archivo recién creado. Tenga en cuenta que todos los directorios que conducen al nuevo directorio ya deben existir.

<p>
Este programa es similar al comando "mkdir" en sistemas operativos tipo Unix y relacionados con MS-DOS.
<p>
El formato general para el comando <tt>mkdir</tt> es:
<blockquote><pre>
java mkdir <i>ruta-del-directorio</i>
</pre></blockquote>
donde:
<dl>
<dt><i>ruta-del-directorio</i></dt>
<dd>es la ruta del directorio a crear (por ejemplo, "/root", o "temp", o "../home/rayo/moss/filesys"). Si <i>ruta-del-directorio</i> no comienza con "/", entonces se anexa a la ruta del directorio de trabajo para el proceso predeterminado.
</dl>

Por ejemplo, el comando:
<blockquote><pre>
java mkdir /home
</pre></blockquote>

crea un directorio llamado "home" como un subdirectorio del directorio raíz del sistema de archivos.

<p>
De manera similar, el comando:
<blockquote><pre>
java mkdir /home/rayo
</pre></blockquote>

crea un directorio llamado "rayo" como un subdirectorio del directorio "home", que se presume que ya existe como un subdirectorio del directorio raíz del sistema de archivos.

<h3><a name="prog.ls">Uso de <tt>ls</tt></a></h3>

El programa <tt>ls</tt> se usa para listar información sobre archivos y directorios en nuestro sistema de archivos simulado. Para cada archivo o nombre de directorio dado, muestra información sobre los archivos nombrados, o en el caso de directorios, para cada archivo en los directorios nombrados.

<p>
Este programa es similar al comando "ls" en sistemas operativos tipo Unix, o al comando "dir" en sistemas operativos relacionados con DOS.

<p>
El formato general para el comando <tt>ls</tt> es:
<blockquote><pre>
java ls <i>nombre-de-ruta ...</i>
</pre></blockquote>
donde:
<dl>
<dt><i>nombre-de-ruta ...</i></dt>
<dd>es una lista separada por espacios de uno o más nombres de ruta de archivo o directorio.</dd>
</dl>

Por ejemplo, el comando:
<blockquote><pre>
java ls /home
</pre></blockquote>

lista el contenido del directorio "/home". Para cada archivo en el directorio, se imprime una línea que muestra el nombre del archivo o subdirectorio, y otra información pertinente como el tamaño.
<p>
La salida del comando debería verse algo así:
<blockquote><pre>

/home:
    1         48 .
    0         48 ..
    2         32 rayo
total de archivos: 3

</pre></blockquote>
En este caso, vemos que el directorio "/home" contiene entradas para ".", "..", y "rayo".

<h3><a name="prog.tee">Uso de <tt>tee</tt></a></h3>

El programa <tt>tee</tt> lee desde la entrada estándar y escribe lo que lee tanto en la salida estándar como en el archivo nombrado. Puede usar este programa para crear archivos en nuestro sistema de archivos simulado con contenido creado en el entorno del sistema operativo.
<p>
Este programa es similar al comando "tee" que se encuentra en muchos sistemas operativos tipo Unix.

<p>
El formato general para el comando <tt>tee</tt> es:
<blockquote><pre>
java tee <i>ruta-del-archivo</i>
</pre></blockquote>
donde:
<dl>
<dt><i>ruta-del-archivo</i></dt>
<dd>es el nombre de un archivo a crear en el sistema de archivos simulado. Si el archivo nombrado ya existe, será sobrescrito.</dd>
</dl>

Por ejemplo:
<blockquote><pre>
echo "hola, amigo" | java tee /home/rayo/hola.txt
</pre></blockquote>
hace que la línea "hola, amigo" se escriba en el archivo "/home/rayo/hola.txt".
<p>
La salida del comando es:
<blockquote><pre>
hola, amigo

</pre></blockquote>
que debe notar que fue la misma que la entrada enviada al programa <tt>tee</tt> por el comando "echo".
<p>
Tenga en cuenta que el "|" (tubería) casi siempre se usa con el programa <tt>tee</tt>. Los usuarios de sistemas operativos tipo Unix encontrarán útiles los comandos "echo" y "cat" para producir entrada para la tubería a <tt>tee</tt>. Los usuarios de sistemas operativos relacionados con MS-DOS encontrarán útiles los comandos "echo" y "type" en este sentido.
<p>
Si desea simplemente ingresar texto directamente a un archivo, puede usar <tt>tee</tt> directamente (es decir, sin la tubería). Los usuarios de sistemas operativos tipo Unix necesitarán usar CTRL-D para señalar el final de la entrada. Los usuarios de sistemas operativos relacionados con MS-DOS necesitarán usar CTRL-Z para señalar el final de la entrada.

<h3><a name="prog.cp">Uso de <tt>cp</tt></a></h3>

El programa <tt>cp</tt> le permite copiar el contenido de un archivo a otro en nuestro sistema de archivos simulado. Si el archivo de destino ya existe, será sobrescrito.
<p>
Este programa es similar al comando "cp" en sistemas operativos tipo Unix, y al comando "copy" en sistemas operativos relacionados con MS-DOS.
<p>
El formato general del comando "cp" es:
<blockquote><pre>
java cp <i>nombre-del-archivo-de-entrada</i> <i>nombre-del-archivo-de-salida</i>
</pre></blockquote>
donde:
<dl>
<dt><i>nombre-del-archivo-de-entrada</i></dt>
<dd>es el nombre de ruta del archivo a copiar (es decir, el archivo <em>fuente</em>), y</dd>
<dt><i>nombre-del-archivo-de-salida</i></dt>
<dd>es el nombre de ruta del archivo a crear (es decir, el archivo <em>destino</em>).</dd>
</dl>

Por ejemplo:
<blockquote><pre>
java cp /home/rayo/hola.txt /home/rayo/saludo.txt
</pre></blockquote>
crea un nuevo archivo "/home/rayo/saludo.txt" copiando en él el contenido del archivo "/home/rayo/hola.txt".

<h3><a name="prog.cat">Uso de <tt>cat</tt></a></h3>

El programa <tt>cat</tt> lee el contenido de un archivo nombrado y lo escribe en la salida estándar. El programa <tt>cat</tt> se usa generalmente para mostrar el contenido de un archivo.
<p>
Este programa es similar al comando "cat" en sistemas operativos tipo Unix, o al comando "type" en sistemas operativos relacionados con MS-DOS.
<p>
El formato general de la línea de comando <tt>cat</tt> es:

<blockquote><pre>
java cat <i>nombre-del-archivo</i>
</pre></blockquote>
donde:
<dl>
<dt><i>nombre-del-archivo</i></dt>
<dd>es el nombre del archivo del cual se leerán los datos para escribir en la salida estándar.
</dl>

Por ejemplo:
<blockquote><pre>
java cat /home/rayo/saludo.txt
</pre></blockquote>
hace que el archivo "/home/rayo/saludo.txt" sea leído, y su contenido se escriba en la salida estándar.
<p>
En este caso, la salida del programa podría verse algo así:
<blockquote><pre>
hola, amigo

</pre></blockquote>

<h2><a name="dump">Volcado del Sistema de Archivos</a></h2>

<p>
Mientras trabaja con el simulador de sistema de archivos, es posible que desee volcar el contenido del archivo de respaldo para <em>ver</em> si contiene lo que <em>cree</em> que contiene. El programa <tt>dump</tt> muestra el contenido de un archivo en el entorno del sistema operativo, un byte a la vez, en varios formatos (hexadecimal, decimal, ASCII).
<p>
Tenga en cuenta que <tt>dump</tt> vuelca el contenido de un archivo real, no un archivo en nuestro sistema de archivos simulado.

<p>
El formato general de la línea de comando <tt>dump</tt> es:
<blockquote><pre>
java dump <i>nombre-del-archivo</i>
</pre></blockquote>
donde:
<dl>
<dt><i>nombre-del-archivo</i>
<dd>es el nombre del archivo a volcar. Este generalmente debe ser el nombre del archivo de respaldo para el simulador de sistema de archivos (por ejemplo, "filesys.dat").
</dl>
El formato general de la salida de volcado es:
<blockquote><pre>
<i>dirección</i> <i>hex</i> <i>dec</i> <i>asc</i>
</pre></blockquote>
donde:
<dl>
<dt><i>dirección</i>
<dd>es la dirección decimal del byte,</dd>
<dt><i>hex</i>
<dd>es el valor hexadecimal del byte,</dd>
<dt><i>dec</i>
<dd>es el valor decimal del byte, y
<dt><i>asc</i>
<dd>es el carácter ASCII correspondiente si el valor está entre 33 y 127 (decimal).
</dl>

Cada línea de la salida de <tt>dump</tt> corresponde a un solo byte en el archivo.
Para mantener la lista breve, <tt>dump</tt> solo muestra bytes no nulos del archivo de entrada.
<p>

Por ejemplo:
<blockquote><pre>
java dump filesys.dat | more
</pre></blockquote>
hace que el contenido del archivo "filesys.dat" se muestre, una línea por byte. El "| more" hace que se le solicite cada página de la salida.
<p>
La primera página de la salida debería verse algo así:
<blockquote><pre>
0 1 1
5 28 40 (
9 1 1
13 2 2
17 a 10
256 1f 31
512 40 64 @
515 3 3
523 30 48 0
527 ff 255
528 ff 255
529 ff 255
530 ff 255
531 ff 255
532 ff 255
533 ff 255
534 ff 255
535 ff 255
536 ff 255
537 ff 255
538 ff 255
539 ff 255
540 ff 255
541 ff 255

</pre></blockquote>
Debe notar, por ejemplo, que el primer bloque (el superbloque) contiene algunos valores numéricos correspondientes al tamaño del bloque (el 1 en el byte 0 significa 256), el número de bloques, etc. El segundo bloque (comenzando en el byte 256) contiene algunos bits que están establecidos, indicando que los primeros bloques están asignados. El tercer bloque (comenzando en 512) contiene algunos nodos índice; los valores FF/255 indican que un bloque directo no está asignado. Un poco más abajo verá ".", y ".." para las entradas de directorio del sistema de archivos raíz, y otros bloques de datos.

<h2><a name="conf">Archivo de Configuración del Simulador</a></h2>

<p>
Cada programa del simulador de sistema de archivos debe llamar a <tt>Kernel.initialize()</tt> antes de llamar a cualquier otro método de <tt>Kernel</tt>. El método <tt>initialize()</tt> lee un archivo de configuración ("filesys.conf" es el predeterminado), abre el archivo de respaldo para el sistema de archivos ("filesys.dat" es el predeterminado), y realiza otras inicializaciones. Esta sección de la guía del usuario describe las diversas opciones que pueden establecerse en el archivo de configuración.

<h3><a name="conf.options">Opciones del Archivo de Configuración</a></h3>

<table border="1">
<tr>
<th>Nombre</th>
<th>Descripción</th>
<th>Valor Predeterminado</th>
<tr>
<td valign=top>filesystem.root.filename</td>
<td valign=top>El nombre del archivo que contiene el sistema de archivos raíz para la simulación.</td>
<td valign=top><tt>filesys.dat</tt></td>
<tr>
<td valign=top>filesystem.root.mode</td>
<td valign=top>El modo a usar al abrir el archivo de respaldo del sistema de archivos raíz. El modo debe ser "rw" para lectura y escritura, o "r" para acceso de solo lectura.</td>
<td valign=top><tt>rw</tt></td>
<tr>
<td valign=top><tt>process.uid</tt></td>
<td valign=top>El identificador de usuario (uid) numérico a usar para el contexto del proceso predeterminado. Este debe ser un número entre 0 y 32767.</td>
<td valign=top><tt>1</tt></td>
<tr>
<td valign=top><tt>process.gid</tt></td>
<td valign=top>El identificador de grupo (gid) numérico a usar para el contexto del proceso predeterminado. Este debe ser un número entre 0 y 32767.</td>
<td valign=top><tt>1</tt></td>
<tr>
<td valign=top><tt>process.umask</tt></td>
<td valign=top>El umask a usar para el contexto del proceso predeterminado. Este debe ser un número octal entre 000 y 777.</td>
<td valign=top><tt>022</tt></td>
<tr>
<td valign=top><tt>process.dir</tt></td>
<td valign=top>El directorio de trabajo en el sistema de archivos simulado a usar para el contexto del proceso predeterminado. Este debe ser una cadena que comience con "/".</td>
<td valign=top><tt>/root</tt>
<tr>
<td valign=top><tt>process.max_open_files</tt></td>
<td valign=top>El número máximo de archivos que pueden estar abiertos al mismo tiempo por un proceso. Cuando se crea un contexto de proceso, se crean tantas ranuras para posibles archivos abiertos.</td>
<td valign=top><tt>10</tt></td>
<tr>
<td valign=top><tt>kernel.max_open_files</tt></td>
<td valign=top>El número máximo de archivos que pueden estar abiertos al mismo tiempo por todos los procesos en la simulación. Cuando el simulador comienza, se crean tantas ranuras para posibles archivos abiertos.</td>
<td valign=top><tt>20</tt></td>
</table>

<h3><a name="conf.sample">Un Archivo de Configuración de Ejemplo</a></h3>

Además del archivo de configuración estándar, "filesys.conf", la distribución también incluye un archivo de configuración de ejemplo más pequeño, "sample.conf". Este se muestra a continuación para ilustrar un archivo de configuración típico.

<blockquote><pre>
!
! mi archivo de configuración personal de filesys
!
filesystem.root.filename = rayo.dat
filesystem.root.mode = r
process.uid = 1000
process.gid = 1000
process.umask = 002
process.dir = /home/rayo

</pre></blockquote>

<p>
En este ejemplo particular, el sistema de archivos está contenido en el archivo de respaldo "rayo.dat", que aquí se abre para acceso de solo lectura. El directorio de trabajo para el contexto del proceso predeterminado es "/home/rayo", con el uid, gid y umask mostrados.

<h3><a name="conf.alt">Especificación de un Archivo de Configuración Alternativo</a></h3>

<p>El archivo de configuración predeterminado se llama "filesys.conf" y está incluido en la distribución de la aplicación. Puede modificar este archivo directamente para establecer varias opciones, o puede crear su propio archivo de configuración y especificar el nombre de este nuevo archivo cuando lance sus programas de simulación.

<p>Si elige crear su propio archivo de configuración, necesitará definir una propiedad del sistema "filesys.conf" que contenga el nombre del archivo. Por ejemplo, suponga que desea ejecutar el programa "ls" usando "my_filesys.conf" como el archivo de configuración. Su comando <tt>java</tt> se vería algo así:
<blockquote><pre>
java -Dfilesys.conf=my_filesys.conf ls /home
</blockquote></pre>
Si no hay un valor establecido para la propiedad del sistema "filesys.conf", entonces el nombre "filesys.conf" se usa como el nombre predeterminado del archivo de configuración.

<h2><a name="writing">Escritura de Programas para el Simulador de Sistema de Archivos</a></h2>

<p>
Escribir programas que usen el Simulador de Sistema de Archivos requiere el uso de la clase <tt>Kernel</tt>, y puede involucrar el uso de las clases <tt>Stat</tt> y <tt>DirectoryEntry</tt>. Si está escribiendo programas ordinarios que usan las llamadas estándar al sistema de archivos, no debería necesitar hacer referencia a ninguna otra clase.
</p>

<p>
Estas tres clases se describen brevemente aquí. Para más información, siga el enlace de la clase al <tt>javadoc</tt> de esa clase.
<dl>
<dt><a href="javadoc/Kernel.html">Kernel</a></dt>
<dd>
configura el entorno del simulador y define todas las llamadas al sistema. Esta clase define: el método <tt>initialize()</tt>, que se usa para inicializar el simulador de sistema de archivos; los métodos <tt>creat()</tt>, <tt>open()</tt>, <tt>read()</tt>, <tt>write()</tt>, <tt>close()</tt>, y otros que simulan el trabajo de un sistema de archivos; y constantes como <tt>EBADF</tt>, <tt>S_IFDIR</tt>, y <tt>O_RDONLY</tt> que se usan para representar parámetros o valores de retorno para las llamadas al sistema. Todos los métodos y campos de Kernel son estáticos; no se instancia un objeto Kernel. Para ejemplos, vea cualquiera de los programas de ejemplo (es decir, <tt>cat.java</tt>, <tt>cp.java</tt>, <tt>ls.java</tt>, etc.)</dd>
<dt><a href="javadoc/Stat.html">Stat</a></dt>
<dd>
es una estructura de datos que representa información sobre un archivo o directorio. Esto pretende representar fielmente la estructura <tt>stat</tt> de Unix. Puede hacer referencia a los campos dentro de un objeto stat directamente (por ejemplo, <tt>stat.st_ino</tt>), o usando métodos de acceso/mutación estilo JavaBean (por ejemplo, <tt>stat.getIno()</tt> o <tt>stat.setIno()</tt>. Los objetos Stat se actualizan mediante los métodos <tt>Kernel.stat()</tt> y <tt>Kernel.fstat()</tt>. Para ejemplos, vea <tt>mkdir.java</tt>.</dd>
<dt><a href="javadoc/DirectoryEntry.html">DirectoryEntry</a></dt>
<dd>
es una estructura de datos que representa un solo registro en un archivo de directorio. Esto pretende representar fielmente una estructura <tt>dirent</tt> de Unix. Contiene un número de nodo índice y un nombre de archivo. Puede hacer referencia a los campos directamente (por ejemplo, <tt>dirent.d_ino</tt>), o usando métodos de acceso/mutación estilo JavaBean (por ejemplo, <tt>dirent.getIno()</tt> o <tt>dirent.setIno()</tt>). Sin embargo, los programadores de Java pueden encontrar más conveniente usar <tt>getName()</tt> y <tt>setName()</tt> (que usan <tt>String</tt>) en lugar del campo <tt>d_name</tt> (que es <tt>byte[]</tt>). Los objetos DirectoryEntry se actualizan mediante el método <tt>Kernel.readdir()</tt>. Para ejemplos, vea <tt>mkdir.java</tt> y <tt>ls.java</tt>.</dd>
</dl>
Para más información sobre las llamadas al sistema de Unix y las estructuras <tt>stat</tt> y <tt>dirent</tt>, consulte un manual del sistema Unix. Los usuarios de sistemas tipo Unix pueden encontrar útiles los comandos "<tt>man -S 2 creat</tt>", "<tt>man -S 2 open</tt>", etc.
<p>
Todos los programas que usan el Simulador de Sistema de Archivos deben seguir las siguientes pautas:
<ul>
<li>Invoque el método <tt><a href="javadoc/Kernel.html#initialize()">Kernel.initialize()</a></tt> antes de cualquier otra llamada al Simulador de Sistema de Archivos.
<li>Use <tt>Kernel.exit()</tt> cuando desee terminar el procesamiento en su programa.
<li>Verifique si hay errores después de cada llamada al sistema (por ejemplo, <tt>creat()</tt>, <tt>open()</tt>, <tt>read()</tt>, <tt>write()</tt>, etc.). Casi todas las llamadas al sistema devuelven -1 si ocurre un error.
<li>Use <tt><a href="javadoc/Kernel.html#perror(java.lang.String)">Kernel.perror()</a></tt> para imprimir el mensaje asociado con un error.
<li>Use <tt><a href="javadoc/Kernel.html#getErrno()">Kernel.getErrno()</a></tt> para determinar qué error ocurrió, si es necesario. Tenga en cuenta que en los programas estándar de Unix, haría referencia a la variable de proceso estática "errno".
</ul>
Para ejemplos, eche un vistazo a los siguientes programas de ejemplo en la distribución:
<ul>
<li><tt><a href="cat.java">cat.java</a></tt>
<li><tt><a href="cp.java">cp.java</a></tt>
<li><tt><a href="ls.java">ls.java</a></tt>
<li><tt><a href="mkdir.java">mkdir.java</a></tt>
<li><tt><a href="tee.java">tee.java</a></tt>
<!-- mkfs ??? -->
</ul>
Colectivamente, estos programas de ejemplo invocan todos los métodos principales (llamadas al sistema) del simulador de sistema de archivos.
</p>

<h2><a name="enhancing">Mejoras al Simulador de Sistema de Archivos</a></h2>

<p>Agregar nuevas características al Simulador de Sistema de Archivos es una excelente manera de profundizar su comprensión del funcionamiento de los sistemas de archivos y de investigar nuevas características. Las mejoras casi seguramente requerirán cambios en la clase <tt>Kernel</tt>, y pueden necesitar cambios en los programas de ejemplo descritos anteriormente. Esta sección describe las otras clases que implementan la funcionalidad del simulador para que pueda entender la organización prevista de estos componentes al hacer una mejora propuesta.
</p>
<p>
Las siguientes son las clases <em>internas</em> para el simulador de sistema de archivos:
<dl>
<dt><tt><a href="javadoc/BitBlock.html">BitBlock</a></tt>
<dd>es una estructura de datos que ve un bloque de dispositivo como una secuencia de bits. Los métodos <tt>setBit()</tt>, <tt>resetBit()</tt>, y <tt>isBitSet()</tt> se usan para establecer, restablecer o verificar un bit en el bloque. Esta estructura se usa para implementar mapas de bits, y es usada por el simulador de sistema de archivos para rastrear bloques de datos asignados y libres en el sistema de archivos. <tt>BitBlock</tt> extiende <tt>Block</tt>.
</dd>
<dt><tt><a href="javadoc/Block.html">Block</a></tt>
<dd>es una estructura de datos que ve un bloque de dispositivo como una secuencia de bytes. El campo <tt>bytes</tt> es un arreglo de <tt>byte</tt>, y es directamente accesible. Se incluyen métodos para <tt>read()</tt> y <tt>write()</tt> el bloque a un <tt>java.io.RandomAccessFile</tt>, que simulan la acción de leer o escribir un bloque de dispositivo.
</dd>
<dt><tt><a href="javadoc/FileDescriptor.html">FileDescriptor</a></tt>
<dd>
es una estructura y colección de métodos que representan un archivo abierto. Incluye varios métodos <tt>get</tt> y <tt>set</tt> para varios detalles de información sobre el archivo abierto, y proporciona métodos <tt>readBlock</tt> y <tt>writeBlock()</tt> para leer y escribir los bloques del archivo.
</dd>
<dt><tt><a href="javadoc/FileSystem.html">FileSystem</a></tt>
<dd>
es una estructura y colección de métodos que representan un sistema de archivos abierto (montado). Incluye algunos métodos <tt>get</tt> y <tt>set</tt> para varios campos sobre el sistema de archivos, pero más importante, incluye métodos para <tt>open()</tt> el archivo detrás del sistema de archivos, para <tt>read()</tt> y <tt>write()</tt> bloques del dispositivo, para gestionar bloques (<tt>allocateBlock()</tt> y <tt>freeBlock()</tt>) y para gestionar inodos (<tt>allocateIndexNode()</tt>). En general, los métodos de <tt>Kernel</tt> deben llamar a los métodos de <tt>FileSystem</tt> cuando quieran leer o escribir datos en el sistema de archivos.
</dd>
<dt><tt><a href="javadoc/IndexNode.html">IndexNode</a></tt>
<dd>
es una estructura y colección de métodos para representar un nodo índice. Esto pretende reflejar la estructura exacta en disco de un nodo índice. Incluye métodos <tt>get</tt> y <tt>set</tt> para cada uno de los campos en el nodo índice. También se incluyen métodos <tt>read()</tt> y <tt>write()</tt> que se usan para copiar datos hacia y desde arreglos de bytes (no archivos de disco).
</dd>
<dt><tt><a href="javadoc/ProcessContext.html">ProcessContext</a></tt>
<dd>
es una estructura y colección de métodos para representar un proceso. Aquí es donde el simulador almacena el uid, gid, umask, dir, y otra información para el proceso actual. Incluye métodos <tt>get</tt> y <tt>set</tt> para cada uno de los campos en un proceso.
</dd>
<dt><tt><a href="javadoc/SuperBlock.html">SuperBlock</a></tt>
<dd>
es una estructura y colección de métodos para representar el superbloque en el disco. En nuestra implementación, el superbloque contiene información sobre el tamaño del bloque, el número de bloques, los desplazamientos al primer bloque de la lista libre, el bloque de inodos, y las áreas de bloques de datos del dispositivo. Incluye métodos <tt>get</tt> y <tt>set</tt> para cada uno de los campos en el superbloque. También se incluyen métodos para <tt>read()</tt> y <tt>write()</tt> el superbloque.
</dd>
</dl>
Por supuesto, debe mirar el código y planificar sus mejoras cuidadosamente.

<h2><a name="exercises">Ejercicios Sugeridos</a></h2>

<ol>
<li>Use <tt>mkfs</tt> para crear un sistema de archivos con un tamaño de bloque de 64 bytes y un total de 8 bloques. ¿Cuántos nodos índice caben en un bloque? ¿Cuántas entradas de directorio caben en un bloque? Use <tt>dump</tt> para examinar el archivo de respaldo del sistema de archivos, y note el valor en el byte 64. ¿Qué representa este valor? Use <tt>mkdir</tt> para crear un directorio (por ejemplo, <tt>/usr</tt>), y luego use <tt>dump</tt> para examinar el byte 64 nuevamente. ¿Qué nota? Repita el proceso de crear un directorio (por ejemplo, <tt>/bin</tt>, <tt>/lib</tt>, <tt>/var</tt>, <tt>/etc</tt>, <tt>/home</tt>, <tt>/mnt</tt>, etc.) y examinar con <tt>dump</tt>. ¿Cuántos directorios puede crear antes de llenar el sistema de archivos? Explique por qué.
<p><!-- --></p>

<li>Mejore <tt>ls.java</tt> para mostrar para cada archivo el uid y gid como números decimales, y los 9 bits de orden inferior del modo como un número octal de 3 dígitos (es decir, 000..777).
<p><!-- --></p>

<li>Escriba un programa <tt>find.java</tt> que, dado un nombre de ruta, verifique si la ruta existe, y si es así, liste ese nombre de ruta y todos los archivos en todos los directorios (y subdirectorios, y sub-subdirectorios, etc.) debajo de él, un nombre de ruta por línea. Por ejemplo:
<blockquote><pre>
java find /home
</pre></blockquote>
podría producir la siguiente salida:
<blockquote><pre>
/home
/home/nathant
/home/nathant/bar.txt
/home/nathant/foo.txt
/home/rayo
/home/rayo/homer
/home/rayo/homer/odyssey.txt
/home/rayo/homer/iliad.txt
/home/rayo/virgil
/home/rayo/virgil/aeneid.txt
/home/rayo/virgil/eclogues.txt
/home/rayo/virgil/georgics.txt
</pre></blockquote>
bajo las circunstancias correctas, por supuesto.
Pista: Su programa puede incluir un método recursivo o un arreglo para mantener un seguimiento de cada directorio a medida que lo abre. ¿Cuál es la profundidad máxima del árbol de directorios con la que su programa funcionará?
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para incluir un nuevo método, <tt>Kernel.chown()</tt>, que, dado el nombre de un archivo, un uid, y un gid, establezca el uid y gid del archivo a los valores dados. Tenga en cuenta que solo el propietario de un archivo (o el superusuario) puede cambiar el gid de un archivo. Solo el superusuario puede cambiar el uid de un archivo. Para probar su nuevo método, escriba dos nuevos programas <tt>chown.java</tt> y <tt>chgrp.java</tt> que acepten un uid o gid (respectivamente) y una lista de nombres de archivos o directorios.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para incluir un nuevo método, <tt>Kernel.chmod()</tt>, que, dado el nombre de un archivo y un modo, establezca el modo del archivo al valor dado. Tenga en cuenta que solo el propietario de un archivo (o el superusuario) puede cambiar el modo de un archivo, y que solo los 9 bits de orden inferior del modo se ven afectados. Para probar su nuevo método, escriba un nuevo programa <tt>chmod.java</tt> que acepte un valor de modo (000..777) y una lista de nombres de archivos o directorios.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para incluir un nuevo método, <tt>Kernel.umask()</tt>, que, dado un umask, guarde ese umask en el contexto del proceso y devuelva el valor <em>anterior</em> del umask. Tenga en cuenta que solo los 9 bits de orden inferior del umask se usan. Además, modifique <tt>Kernel.creat()</tt> para que el modo para los archivos recién creados sea el AND lógico del modo dado y el <em>complemento</em> del valor actual del umask del contexto del proceso.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para incluir un nuevo método, <tt>Kernel.link()</tt>, que, dados dos nombres de ruta, cree la segunda ruta como un enlace (duro) a la primera ruta. <tt>link()</tt> debe encontrar el número de inodo para el primer archivo, y luego escribir una entrada de directorio para la segunda ruta que haga referencia al mismo nodo índice. No olvide incrementar nlink en el nodo índice. Para probar su nuevo método, escriba un nuevo programa, <tt>ln.java</tt>, que, dados dos nombres de ruta, realice la operación <tt>link()</tt>. Asuma que no se permite crear un enlace a un directorio.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para incluir un nuevo método, <tt>Kernel.unlink()</tt>, que, dado el nombre de un archivo, elimine la entrada de directorio para ese archivo y decremente <tt>nlink</tt> para el nodo índice. Si <tt>nlink</tt> se decrementa a cero, libere todos los bloques del archivo. Si el archivo está actualmente abierto por cualquier proceso, marque el archivo para que los bloques se liberen cuando el archivo sea cerrado por el último proceso. Para probar su nuevo método, escriba un nuevo programa <tt>rm.java</tt> que acepte los nombres de los archivos a desvincular. Asuma que no se permite desvincular un directorio.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para incluir un nuevo método, <tt>Kernel.access()</tt>, que, dado el nombre de un archivo y un modo, determine si el proceso actual puede acceder al archivo en el modo deseado. En este caso, el modo puede ser 4 (lectura), 2 (escritura), 1 (ejecución), o cualquier combinación de estos. Si el modo es 0, solo se verifican los directorios que conducen al archivo para acceso de lectura.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para rastrear <tt>atime</tt>, <tt>mtime</tt>, y <tt>ctime</tt> para operaciones de archivos y directorios. Considere usar <tt>java.util.Date(long)</tt>, <tt>java.util.Date.getTime()</tt>, y <tt>java.util.Date.setTime(long)</tt> como parte de su solución.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para soportar bloques indirectos, y bloques doble y triple indirectos.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para soportar una forma simplificada de compartición de archivos. Asuma que un archivo no puede ser abierto para escritura si ya está abierto por cualquier proceso; un archivo puede estar abierto concurrentemente cualquier número de veces para lectura.
<p><!-- --></p>

<li>Mejore el simulador de sistema de archivos para permitir el uso de una lista en lugar de un mapa de bits para rastrear bloques de datos libres. Modifique <tt>mkfs.java</tt> para permitir que el usuario ingrese un cuarto parámetro para elegir entre <tt>free-list</tt> y <tt>free-bitmap</tt>.
<p><!-- --></p>

<li>Escriba un programa llamado <tt>fsck.java</tt> que verifique un sistema de archivos en busca de consistencia interna. Por ejemplo, debe verificar que todos los inodos mencionados en las entradas de directorio tengan el número correcto de nlink, y que todos los bloques mencionados en los inodos estén marcados como bloques asignados, y todos los bloques NO mencionados en los inodos estén marcados como bloques libres. Para una descripción más completa de <tt>fsck</tt>, consulte el texto.
<p><!-- --></p>

</ol>
<!--
  df
  lsof
<li>Escriba un programa llamado <tt>lsof.java</tt>, que liste todos los archivos abiertos en todos los sistemas de archivos abiertos. ??? ¿Cómo decimos el nombre bajo el cual el archivo está abierto?
  ??? ¿usa rmdir() unlink()?
  link(), symlink()
  cualquier cosa relacionada con múltiples procesos
  cualquier cosa relacionada con múltiples sistemas de archivos
-->

<h2><a name="todo">Por Hacer</a></h2>
<ol>
<li>Intentar crear o abrir para escritura un archivo en un sistema de archivos de solo lectura debería devolver EROFS, no una IOException.
<li>El programa <tt>cp</tt> no verifica que los archivos de entrada y salida no sean archivos de directorio, pero debería.
<li>Los programas <tt>cp</tt> y <tt>tee</tt> no son cuidadosos con el modo usado para el archivo de salida, pero deberían serlo.
</ol>

<h2><a name="copyright">Derechos de Autor</a></h2>

&copy; Copyright 2001, Prentice-Hall, Inc.
<p>
Este programa es software libre; puede redistribuirlo y/o modificarlo bajo los términos de la Licencia Pública General GNU publicada por la Free Software Foundation; ya sea la versión 2 de la Licencia, o (a su elección) cualquier versión posterior.
<p>
Este programa se distribuye con la esperanza de que sea útil, pero SIN NINGUNA GARANTÍA; sin siquiera la garantía implícita de COMERCIALIZACIÓN o IDONEIDAD PARA UN PROPÓSITO PARTICULAR. Consulte la Licencia Pública General GNU para más detalles.
<p>
Debería haber recibido una copia de la Licencia Pública General GNU junto con este programa (vea <a href="copying.txt">copying.txt</a>); si no, escriba a la Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
<p>

Por favor, envíe sugerencias, correcciones y comentarios a
<a href="http://www.ontko.com/~rayo/">Ray Ontko</a> 
(<a href="mailto:rayo@ontko.com"><i>rayo@ontko.com</i></a>).
<p>
<i>Última actualización: 3 de octubre de 2001</i>
</body>
</html>